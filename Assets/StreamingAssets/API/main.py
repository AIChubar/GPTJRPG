import openai
import os
import json

structure_file = open("example.json", "r")
units_file = open("enemies.txt", "r")
tile_palettes_file = open("palettes.txt", "r")
existingWorlds = os.listdir(os.path.join(os.pardir, "Worlds"))

structure_content = structure_file.read()
units_content = units_file.read()
palettes_content = tile_palettes_file.read()

response = openai.chat.completions.create(
    model="gpt-3.5-turbo-0125",
    temperature=0.8,
    max_tokens=4000,
    response_format={"type": "json_object"},
    messages=[
        {
            "role": "system",
            "content": "#Setting: \n You are an assistant for creating textual game content. The output should be in "
                       "JSON format, according to a structure I provide you later.\n"
                       "#Instructions: \n Your main task is to replace placeholder values in JSON variables with "
                       "content generated by you, strictly following the constraints I provide.\n"
                       "Replace \"...\" according to the previous structure parts. \n"
                       "Generate Health and Damage as an integer value, balance it out so average ally units are about 70% stronger than average enemy units which base stats are around 50 hp and 10 damage.\n"
                       "#Structure: \n" + structure_content + "\n"
                       "#Constraints: \n"
                       "1. Fill the tilePalette variable in the resulting JSON only with one exact string including numerical id from the provided list: " + palettes_content.replace('\n', ' ') + "\n"
                       "First part of the tilePalette id represents walkable tiles description. Do not use the same walkable tile description for different levels (i.e you cannot use snow more than 2 times or grass more than 2 times)" + "\n"
                       "2. Fill the unitID for enemies and ally groups variable in the resulting JSON only with exact strings including numerical id from the provided list: " + units_content.replace('\n', ' ') + "\n"
                       "3. Try to generate enemy units to be aligned with chosen tile palette theme. \n"
                       "4. Always separate generated names words with spaces for example: not FirstSecond, but First Second. \n"
                       "5. It is forbidden to change the numerical id or the id from the list itself. \n"
                       "6. unitName can be filled with the name that will be representing unitID and should be logically connected to it. Do not include words new or old in unitName. Do not change the meaning when creating unitName too much.\n"
                       "7. Do not use names from this list for the worldName, and try to make names dissimilar to those in the list of existing worlds: \n" + "\n".join(existingWorlds) + "\n"
                       "8. Do not modify lists provided. \n"
                       "9. Use at most two same unitID in each group. There should be at least two enemies in each enemyGroup. \n"
                       "10. Two levels. Five enemy groups in each level. \n"
                       "11. Do not use same ids for enemies and allies, try to use logically different units for enemies and allies. \n"
                       "12. Never include .json in worldName. WorldName can consist of several words. \n"
                       "13. Fill battleStartMonologue with a phrase that enemy in the first slot of the group is telling to the player before battle starts. \n"
                       "14. Fill winMonologue with a phrase that enemy in the first slot of the group is telling to the player if the player won in the battle before death of enemies. \n"
                       "15. Fill lostMonologue with a phrase that enemy in the first slot of the group is telling to the player if the player lost in the battle and is about to die. \n"
                       "16. Every monologue should be at least 3 sentences or 25 words long. Try to be informal. \n"
        },
        {
            "role": "user",
            "content": "Start generating."
        }
    ]
)

json_result = json.loads(response.choices[-1].message.content)
with open(os.path.join(os.pardir, "Worlds", json_result["narrativeData"]["worldName"] + ".json"), 'w') as f:
    json.dump(json_result, f, indent=2)

structure_file.close()
units_file.close()
tile_palettes_file.close()
print(response.choices[0].message.content)
